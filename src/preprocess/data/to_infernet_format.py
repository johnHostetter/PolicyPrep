"""
This Python module contains the code to generate training data with action and reward columns. This
expects the data to be in the format generated by the `download_data.py` script. The data used must be from
the post-processing step; for example, features_all.csv must be from the PostProcessing folder, not the
Experiment folder. The generated format of the training data is required for the InferNet code.
"""
# import sys
from typing import Tuple, Union

import pandas as pd

from src.utils.reproducibility import load_configuration, path_to_project_root


def make_year_and_semester_int(semester) -> Union[Tuple[int, int], None]:
    """
    Convert a semester string to a year and semester integer.

    Args:
        semester: A string representing a semester, e.g. 'F19'.

    Returns:
        A tuple of the year and semester integers, following our lab's naming convention. If the
        semester string is invalid, then return None.
    """
    year_int = int(semester[1:]) * 10000

    if semester[0] == 'S':
        return year_int, 1000
    elif semester[0] == 'F':
        return year_int, 3000
    return None


def minimum_id(semester) -> int:
    """
    Get the minimum user ID for a given semester.

    Args:
        semester: A string representing a semester, e.g. 'F19'.

    Returns:
        The minimum user ID for the given semester.
    """
    year_int, semester_int = make_year_and_semester_int(semester)
    return year_int + semester_int + 100


if __name__ == "__main__":
    # load the configuration settings
    pd.options.mode.chained_assignment = None
    config = load_configuration("default_configuration.yaml")

    # iterate over the different semesters of training data

    semester_folder_path_generator = (path_to_project_root() / "data" / "raw").glob(
        "* - *"
    )
    for semester_folder in semester_folder_path_generator:
        if not semester_folder.is_dir():
            print(f"Skipping {semester_folder.name} (not a directory)...")
            continue
        if " - " not in semester_folder.name:
            print(f"Skipping {semester_folder.name} (invalid directory name)...")
            continue
        if semester_folder.name not in ["11 - F21"]:
            # TODO: track down why this semester does not work
            print(f"Skipping {semester_folder.name} (invalid data for this semester)...")
            continue  # more specifically, the step-level data is mismatched
        # the name of the semester is the part of the folder name after the " - "
        # e.g. "10 - S21" -> "S21"; the part before the " - " is the folder ordering number
        (_, semester_name) = semester_folder.name.split(" - ")
        print(f"Processing data for the {semester_name} semester...")

        year_int, semester_int = make_year_and_semester_int(semester_name)

        # load the data

        substep_info_df = pd.read_csv(
            str(semester_folder / "PostProcessing" / "substep_info.csv"), header=0
        )
        substep_info_df["userID"] = substep_info_df["userID"].astype(int)
        substep_info_df["userID"] = year_int + semester_int + substep_info_df["userID"]
        summary_df = pd.read_csv(
            str(
                path_to_project_root() / "data" / "weighted_F15_F22.csv"
            ),
            header=0,
        )

        # make the output directories for the training data
        output_directory = path_to_project_root() / "data" / "with_delayed_rewards" / semester_name
        output_directory.mkdir(
            parents=True, exist_ok=True
        )

        # try:
        #     summary_df = pd.read_csv(
        #         str(
        #             semester_folder / "Summary" / f"{semester_name}_experiment_summary.csv"
        #         ),
        #         header=0,
        #     )
        #
        #     # make the output directories for the training data
        #     output_directory = path_to_project_root() / "data" / "with_delayed_rewards" / semester_name
        #     output_directory.mkdir(
        #         parents=True, exist_ok=True
        #     )
        #
        # except FileNotFoundError:
        #     print(
        #         f"Skipping {semester_folder.name} (no summary file found for this semester)..."
        #     )
        #     continue

        problems = substep_info_df["problem"].unique()
        problems = [
            p
            for p in problems
            if (p[-1] != "w" and "ex222" not in p and "ex144" not in p)
        ]  # Exclude all wording problems and ex222 and ex144 who won't be trained for step-level anyway

        # #Problem-Level Training Data with action and reward columns
        prob_features = pd.read_csv(
            str(semester_folder / "PostProcessing" / "features_all.csv"),
            header=0,
            usecols=config.data.features.basic + config.data.features.problem,
        )
        # userCount = len(features["userID"].unique())

        prob_features["userID"] = prob_features["userID"] + year_int + semester_int
        prob_features = prob_features[prob_features['userID'] > minimum_id(semester_name)]

        problemLevelFeatureFrame = prob_features[
            prob_features["decisionPoint"].isin(["probStart", "probEnd"])
        ]

        # # make sure that each student only has 10 rows (1 for each problem)
        # keep_boolean_mask = problemLevelFeatureFrame.groupby(by="userID")[
        #                         "problem"].count().values == 10
        # keep_user_ids = problemLevelFeatureFrame.groupby(by="userID")[
        #                     "problem"].count().index[keep_boolean_mask]
        #
        # # filter out the users that don't have 10 rows
        # problemLevelFeatureFrame = problemLevelFeatureFrame[
        #     problemLevelFeatureFrame["userID"].isin(keep_user_ids)
        # ]
        #
        # user_count = len(keep_user_ids)

        problemLevelFeatureFrame.drop(
            problemLevelFeatureFrame[
                (problemLevelFeatureFrame["decisionPoint"] == "probEnd")
                & (~problemLevelFeatureFrame["problem"].isin(["ex252", "ex252w"]))
                ].index,
            inplace=True,
        )
        problemLevelFeatureFrame["action"] = ""
        problemLevelFeatureFrame["reward"] = ""
        actionColumnLocation = problemLevelFeatureFrame.columns.get_loc("action")
        rewardColumnLocation = problemLevelFeatureFrame.columns.get_loc("reward")

        for i in range(len(problemLevelFeatureFrame)):
            userID = problemLevelFeatureFrame.iloc[i]["userID"]
            decisionPoint = problemLevelFeatureFrame.iloc[i]["decisionPoint"]
            if decisionPoint == "probStart":
                problem = problemLevelFeatureFrame.iloc[i]["problem"]
                uniqueActions = substep_info_df[
                    (substep_info_df["userID"] == userID)
                    & (substep_info_df["problem"] == problem)
                    ]["substepMode"].unique()
                if len(uniqueActions) == 2:
                    problemLevelFeatureFrame.iat[
                        i, actionColumnLocation
                    ] = "step_decision"
                else:
                    try:
                        problemLevelFeatureFrame.iat[i, actionColumnLocation] = uniqueActions[0]
                    except IndexError:
                        problemLevelFeatureFrame.iat[i, actionColumnLocation] = uniqueActions
            else:
                if len(summary_df[summary_df['userID'] == userID]['nlg'].unique()) == 0:
                    continue  # the result is empty list, skip this user
                else:
                    nlg = summary_df[summary_df['userID'] == userID]['nlg'].unique()[0]
                    problemLevelFeatureFrame.iat[i, rewardColumnLocation] = nlg

        # save the problem-level training data
        print(f"Saving problem-level training data for the {semester_name} semester...")
        problemLevelFeatureFrame.to_csv(
            output_directory / "problem_level.csv", index=False
        )

        # Step-Level Training Data with action column
        step_features = pd.read_csv(
            str(semester_folder / "PostProcessing" / "features_all.csv"),
            header=0,
            usecols=config.data.features.basic + config.data.features.step,
        )

        step_features["userID"] = step_features["userID"] + year_int + semester_int

        for problem in problems:
            stepLevelFeatureFrame = step_features[
                (step_features["decisionPoint"].isin(["stepStart", "probEnd"]))
                & (step_features["problem"].isin([problem, problem + "w"]))
                ]
            stepLevelFeatureFrame["action"] = ""
            stepLevelFeatureFrame["reward"] = ""
            actionColumnLocation = stepLevelFeatureFrame.columns.get_loc("action")
            stepLevelSubStepFrame = substep_info_df[
                substep_info_df["problem"].isin([problem, problem + "w"])
            ]

            # make the user IDs consistent with each other
            year_int, semester_int = make_year_and_semester_int(semester_name)

            if any(stepLevelFeatureFrame.userID < 1000):
                stepLevelFeatureFrame.userID += year_int + semester_int
            if any(stepLevelSubStepFrame.userID < 1000):
                stepLevelSubStepFrame.userID += year_int + semester_int

            # select the minimal set of user IDs to make the data agree with each other
            userIDs = set(stepLevelFeatureFrame.userID.unique()).intersection(
                stepLevelSubStepFrame.userID.unique())
            # user IDs below 100 are considered test users, remove them
            userIDs = [userID for userID in userIDs if userID > minimum_id(semester_name)]
            user_count = len(userIDs)

            # make them consistent with each other
            stepLevelFeatureFrame = stepLevelFeatureFrame[
                stepLevelFeatureFrame.userID.isin(userIDs)]
            stepLevelSubStepFrame = stepLevelSubStepFrame[
                stepLevelSubStepFrame.userID.isin(userIDs)]

            # Feature Frame has an extra "probEnd" per problem per user. Since we are at the current problem, it has an additional #NumberofUser rows
            if len(stepLevelFeatureFrame) != len(stepLevelSubStepFrame) + user_count:
                print("feature_all and substep_info length mismatch at step-level")
                continue
                # sys.exit(1)

            sub_step_counter = 0
            for i in range(len(stepLevelFeatureFrame)):
                decisionPoint = stepLevelFeatureFrame.iloc[i]["decisionPoint"]
                if decisionPoint != "stepStart":
                    continue
                userIDFeature = stepLevelFeatureFrame.iloc[i]["userID"]
                userIDSubStep = stepLevelSubStepFrame.iloc[sub_step_counter]["userID"]

                if userIDFeature != userIDSubStep:
                    print(
                        "UserID mismatch between feature_all and substep_info at step-level: Feature -> "
                        + str(userIDFeature)
                        + ", subStep -> "
                        + str(userIDSubStep)
                    )
                    continue
                    # sys.exit(1)

                stepLevelFeatureFrame.iat[
                    i, actionColumnLocation
                ] = stepLevelSubStepFrame.iloc[sub_step_counter]["substepMode"]
                sub_step_counter += 1

            # save the step-level training data for this current problem
            print(f"Saving {problem} step-level training data for the {semester_name} semester...")
            stepLevelFeatureFrame.to_csv(
                output_directory / f"{problem}(w).csv", index=False
            )
