"""
This Python module contains the code to generate training data with action and reward columns. This
expects the data to be in the format generated by the `download_data.py` script. The data used must be from
the post-processing step; for example, features_all.csv must be from the PostProcessing folder, not the
Experiment folder. The generated format of the training data is required for the InferNet code.
"""
from typing import Tuple, Union

import pandas as pd

from src.utils.reproducibility import load_configuration, path_to_project_root


def make_year_and_semester_int(semester: str) -> Union[Tuple[int, int], None]:
    """
    Convert a semester string to a year and semester integer.

    Args:
        semester: A string representing a semester, e.g. 'F19'.

    Returns:
        A tuple of the year and semester integers, following our lab's naming convention. If the
        semester string is invalid, then return None.
    """
    year_int = int(semester[1:]) * 10000

    if semester[0] == "S":
        return year_int, 1000
    elif semester[0] == "F":
        return year_int, 3000
    return None


def minimum_id(semester: str) -> int:
    """
    Get the minimum user ID for a given semester.

    Args:
        semester: A string representing a semester, e.g. 'F19'.

    Returns:
        The minimum user ID for the given semester.
    """
    year_int, semester_int = make_year_and_semester_int(semester)
    return year_int + semester_int + 100


def iterate_over_semester_data() -> None:
    """
    Iterate over the different semesters of training data and generate the training data with action and reward
    columns.

    Returns:
        None
    """
    # load the configuration settings
    pd.options.mode.chained_assignment = None
    config = load_configuration("default_configuration.yaml")

    # iterate over the different semesters of training data

    semester_folder_path_generator = (path_to_project_root() / "data" / "raw").glob(
        "* - *"
    )
    for semester_folder in semester_folder_path_generator:
        if not semester_folder.is_dir():
            print(f"Skipping {semester_folder.name} (not a directory)...")
            continue
        if " - " not in semester_folder.name:
            print(f"Skipping {semester_folder.name} (invalid directory name)...")
            continue
        # the name of the semester is the part of the folder name after the " - "
        # e.g. "10 - S21" -> "S21"; the part before the " - " is the folder ordering number
        (_, semester_name) = semester_folder.name.split(" - ")
        print(f"Processing data for the {semester_name} semester...")

        year_int, semester_int = make_year_and_semester_int(semester_name)

        # load the data

        substep_info_df = pd.read_csv(
            str(semester_folder / "PostProcessing" / "substep_info.csv"), header=0
        )
        substep_info_df["userID"] = substep_info_df["userID"].astype(int)
        substep_info_df["userID"] = year_int + semester_int + substep_info_df["userID"]
        summary_df = pd.read_csv(
            str(path_to_project_root() / "data" / "weighted_F15_F22.csv"),
            header=0,
        )

        # make the output directories for the training data
        output_directory = (
            path_to_project_root() / "data" / "with_delayed_rewards" / semester_name
        )
        output_directory.mkdir(parents=True, exist_ok=True)

        # try:
        #     summary_df = pd.read_csv(
        #         str(
        #             semester_folder / "Summary" / f"{semester_name}_experiment_summary.csv"
        #         ),
        #         header=0,
        #     )
        #
        #     # make the output directories for the training data
        #     output_directory = path_to_project_root() / "data" / "with_delayed_rewards" / semester_name
        #     output_directory.mkdir(
        #         parents=True, exist_ok=True
        #     )
        #
        # except FileNotFoundError:
        #     print(
        #         f"Skipping {semester_folder.name} (no summary file found for this semester)..."
        #     )
        #     continue

        problems = substep_info_df["problem"].unique()
        problems = [
            p
            for p in problems
            if (p[-1] != "w" and "ex222" not in p and "ex144" not in p)
        ]  # Exclude all wording problems and ex222 and ex144 who won't be trained for step-level anyway

        # #Problem-Level Training Data with action and reward columns
        prob_features = pd.read_csv(
            str(semester_folder / "PostProcessing" / "features_all.csv"),
            header=0,
            usecols=config.data.features.basic + config.data.features.problem,
        )
        # userCount = len(features["userID"].unique())

        prob_features["userID"] = prob_features["userID"] + year_int + semester_int
        prob_features = prob_features[
            prob_features["userID"] > minimum_id(semester_name)
        ]

        prob_lvl_feature_df = prob_features[
            prob_features["decisionPoint"].isin(["probStart", "probEnd"])
        ]

        # # make sure that each student only has 10 rows (1 for each problem)
        # keep_boolean_mask = prob_lvl_feature_df.groupby(by="userID")[
        #                         "problem"].count().values == 10
        # keep_user_ids = prob_lvl_feature_df.groupby(by="userID")[
        #                     "problem"].count().index[keep_boolean_mask]
        #
        # # filter out the users that don't have 10 rows
        # prob_lvl_feature_df = prob_lvl_feature_df[
        #     prob_lvl_feature_df["userID"].isin(keep_user_ids)
        # ]
        #
        # user_count = len(keep_user_ids)

        prob_lvl_feature_df.drop(
            prob_lvl_feature_df[
                (prob_lvl_feature_df["decisionPoint"] == "probEnd")
                & (~prob_lvl_feature_df["problem"].isin(["ex252", "ex252w"]))
            ].index,
            inplace=True,
        )
        prob_lvl_feature_df["action"] = ""
        prob_lvl_feature_df["reward"] = ""
        action_col_location = prob_lvl_feature_df.columns.get_loc("action")
        reward_col_location = prob_lvl_feature_df.columns.get_loc("reward")

        for i in range(len(prob_lvl_feature_df)):
            user_id = prob_lvl_feature_df.iloc[i]["userID"]
            decision_point = prob_lvl_feature_df.iloc[i]["decisionPoint"]
            if decision_point == "probStart":
                problem = prob_lvl_feature_df.iloc[i]["problem"]
                unique_actions = substep_info_df[
                    (substep_info_df["userID"] == user_id)
                    & (substep_info_df["problem"] == problem)
                ]["substepMode"].unique()
                if len(unique_actions) == 2:
                    prob_lvl_feature_df.iat[i, action_col_location] = "step_decision"
                else:
                    try:
                        prob_lvl_feature_df.iat[
                            i, action_col_location
                        ] = unique_actions[0]
                    except IndexError:
                        prob_lvl_feature_df.iat[i, action_col_location] = unique_actions
            else:
                if (
                    len(summary_df[summary_df["userID"] == user_id]["nlg"].unique())
                    == 0
                ):
                    continue  # the result is empty list, skip this user
                else:
                    nlg = summary_df[summary_df["userID"] == user_id]["nlg"].unique()[0]
                    prob_lvl_feature_df.iat[i, reward_col_location] = nlg

        # save the problem-level training data
        print(f"Saving problem-level training data for the {semester_name} semester...")
        prob_lvl_feature_df.to_csv(output_directory / "problem_level.csv", index=False)

        # Step-Level Training Data with action column
        step_features = pd.read_csv(
            str(semester_folder / "PostProcessing" / "features_all.csv"),
            header=0,
            usecols=config.data.features.basic + config.data.features.step,
        )

        step_features["userID"] = step_features["userID"] + year_int + semester_int

        for problem in problems:
            step_lvl_feature_df = step_features[
                (step_features["decisionPoint"].isin(["stepStart", "probEnd"]))
                & (step_features["problem"].isin([problem, problem + "w"]))
            ]
            step_lvl_feature_df["action"] = ""
            step_lvl_feature_df["reward"] = ""
            action_col_location = step_lvl_feature_df.columns.get_loc("action")
            step_lvl_substep_df = substep_info_df[
                substep_info_df["problem"].isin([problem, problem + "w"])
            ]

            # make the user IDs consistent with each other
            year_int, semester_int = make_year_and_semester_int(semester_name)

            if any(step_lvl_feature_df.userID < 1000):
                step_lvl_feature_df.userID += year_int + semester_int
            if any(step_lvl_substep_df.userID < 1000):
                step_lvl_substep_df.userID += year_int + semester_int

            # select the minimal set of user IDs to make the data agree with each other
            user_ids = set(step_lvl_feature_df.userID.unique()).intersection(
                step_lvl_substep_df.userID.unique()
            )
            # user IDs below 100 are considered test users, remove them
            user_ids = [
                user_id for user_id in user_ids if user_id > minimum_id(semester_name)
            ]
            user_count = len(user_ids)

            # make them consistent with each other
            step_lvl_feature_df = step_lvl_feature_df[
                step_lvl_feature_df.userID.isin(user_ids)
            ]
            step_lvl_substep_df = step_lvl_substep_df[
                step_lvl_substep_df.userID.isin(user_ids)
            ]

            # Feature Frame has an extra "probEnd" per problem per user. Since we are at the current problem, it has an additional #NumberofUser rows
            if len(step_lvl_feature_df) != len(step_lvl_substep_df) + user_count:
                print("feature_all and substep_info length mismatch at step-level")
                continue
                # sys.exit(1)

            sub_step_counter = 0
            for i in range(len(step_lvl_feature_df)):
                decision_point = step_lvl_feature_df.iloc[i]["decisionPoint"]
                if decision_point != "stepStart":
                    continue
                user_id_feature = step_lvl_feature_df.iloc[i]["userID"]
                user_id_substep = step_lvl_substep_df.iloc[sub_step_counter]["userID"]

                if user_id_feature != user_id_substep:
                    print(
                        "UserID mismatch between feature_all and substep_info at step-level: Feature -> "
                        + str(user_id_feature)
                        + ", subStep -> "
                        + str(user_id_substep)
                    )
                    continue
                    # sys.exit(1)

                step_lvl_feature_df.iat[
                    i, action_col_location
                ] = step_lvl_substep_df.iloc[sub_step_counter]["substepMode"]
                sub_step_counter += 1

            # save the step-level training data for this current problem
            print(
                f"Saving {problem} step-level training data for the {semester_name} semester..."
            )
            step_lvl_feature_df.to_csv(
                output_directory / f"{problem}(w).csv", index=False
            )


if __name__ == "__main__":
    iterate_over_semester_data()
